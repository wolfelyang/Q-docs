{
    "docs": [
        {
            "location": "/",
            "text": "Maana Knowledge Platform\n\n\nGuides\n\n\n\n\nUser\n\n\nDeveloper\n\n\nAdministrator",
            "title": "Home"
        },
        {
            "location": "/#maana-knowledge-platform",
            "text": "",
            "title": "Maana Knowledge Platform"
        },
        {
            "location": "/#guides",
            "text": "User  Developer  Administrator",
            "title": "Guides"
        },
        {
            "location": "/user/",
            "text": "User Guide\n\n\nWhat is Maana?\n\n\nKnowledge Portal",
            "title": "User Guide"
        },
        {
            "location": "/user/#user-guide",
            "text": "",
            "title": "User Guide"
        },
        {
            "location": "/user/#what-is-maana",
            "text": "",
            "title": "What is Maana?"
        },
        {
            "location": "/user/#knowledge-portal",
            "text": "",
            "title": "Knowledge Portal"
        },
        {
            "location": "/developer/",
            "text": "Research and Development : Developer Guide  \n\n\n\n\nResearch and Development\n\n\n\n\nResearch and Development : Developer Guide\n\n\nCreated by Marius Marcu, last modified by Donald Thompson on Jul 12, 2018\n\n\nOld Word Doc: \nOLD Developer Guide OLD\n\n\nDocument name\n\n\nAudience\n\n\nDescription\n\n\nKnowledge Technology Development Guide\n\n\nSolution Engineers and Data Scientists\n\n\ndetails the architecture of the platform, how to build a full solution and/or reusable components\n\n\nTable of Contents\n\n\n/\n<![CDATA[\n/ div.rbtoc1532523907698 {padding: 0px;} div.rbtoc1532523907698 ul {list-style: disc;margin-left: 0px;} div.rbtoc1532523907698 li {margin-left: 0px;padding-left: 0px;} /\n]]>\n/\n\n\n\n\nTable of Contents\n\n\nIntroduction\n\n\nGraphQL and Microservices\n\n\nGraphQL Learning Resources\n\n\n\n\n\n\nKnowledge Microservices and Bots\n\n\nDevelopment Stages\n\n\nStage: Design\n\n\nStage: Local Service (Standalone)\n\n\nStage: Local Service (Maana)\n\n\nStage: Unmanaged Service\n\n\nStage: Managed Service\n\n\n\n\n\n\nDebugging a Knowledge Microservice\n\n\nThe BotAction Protocol\n\n\n\n\n\n\nKnowledge Applications\n\n\nDevelopment Environments\n\n\nVisual Studio Code\n\n\nCommand Line\n\n\nRecommended Plugins\n\n\nSettings\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nThe Maana platform is built from a network of \nGraphQL\n-based \nmicroservices\n. Unlike pure client-server or n-tier architectures, Maana's microservices act as peers in an asynchronous and loosely-coupled arrangement that promotes independent scaling and extensibility. These services provide identity and access controls, graph persistence, search, machine learning, and natural language processing. Ultimately, these services provide reasoning capabilities to Knowledge Applications, which help solve domain-specific problems and support optimal decision-making capable of learning over time.\n\n\nThis guide is intended for Solution Developers and Data Scientists and describes how to develop such services (aka \"bots\") and applications and operationalize them in a production setting.\n\n\nGraphQL and Microservices\n\n\nAt the core of any Maana solution sits a Knowledge Graph, which consists of \nconcepts\n and \nproperties\n, \ninstances\n and \nvalues\n, and \nrelations\n and \nlinks\n. For example, consider the concept of a \nContainerShip\n with properties \nname\n, \nlength\n, \nposition\n, etc. A specific instance (entity) has values for each of the properties, such as the Maersk Viking with a length of \n400 meters\n, ... Such properties can be \nscalar\n (e.g., numbers, strings, dates) or might refer to other concepts/instances, e.g., ships \nhold Cargo\n. In some cases, property values for an instance are simply stored, since they don't change (often). In other cases, they are dynamically computed, such as a ship's \nweight\n (which depends on its cargo) or its \ncurrent position\n (which requires getting a GPS reading).\n\n\nGraphQL\n is a data query language created by Facebook and open-sourced in 2015 as an alternative to REST interfaces. Maana uses GraphQL to represent and expose its Knowledge Graph\n\n\nUnlike a traditional \ngraph database\n, Maana incorporate arbitrary computation (through custom GraphQL resolvers) and distributes the graph into subgraphs managed by different \nmicroservices\n, optionally with their own dedicated persistence mechanism.\n\n\nWhile this approach allows for flexibility, it places more responsibility on the microservices to provide their own storage. To address this, Maana proposes an explicit split between the data models (i.e., GraphQL type definitions) that a service uses and its operations (i.e., GraphQL resolvers). Maana will generate the appropriate managed service for such models using \nKindDB\n, Prisma, neo4j, ... The solution developer, then, only provides the logic they care about and let the system take care of all the CRUD/ORM-like operations on the data.\n\n\nThe \nComputational Knowledge Graph (CKG)\n, itself a microservice, provides automatic persistence, boilerplate queries and mutations, and service orchestration capabilities. Taken together, these service allow the solution developer to focus on \ndesigning GraphQL schemas\n and implementing \ncomputational resolvers\n only where needed.\n\n\nGraphQL Learning Resources\n\n\n\n\nHow to GraphQL\n\n\n\n\nKnowledge Microservices and Bots\n\n\nA \nGraphQL service\n (endpoint) consists of:\n\n\n\n\ntypes\n\n\nqueries\n\n\nmutations\n\n\nevents\n (pub/sub)\n\n\n\n\nA \nKnowledge Microservice\n is a GraphQL service that also includes:\n\n\n\n\nauthenticated access\n\n\nclient/server boilerplate\n\n\nreliable messaging using RabbitMQ\n\n\nlifecycle management (info, register, deregister)\n\n\nDocker containerization and automatic scaling/load balancing\n\n\n\n\nA \nBot\n is a Knowledge Microservice that provides specialized queries and mutations that perform \nBotActions\n, which allow the bot to provide asynchronous status updates. This enables user interface components to reflect the latest status of \nlong-running operations\n or \nautomatically triggered events\n, e.g., entity recognition, new concept creation, classification.\n\n\nAll \nKinds\n (concepts, types) are associated with a service. This service is said to \nprovide\n the (entities of) the Kind. Many Kinds are purely extensional (i.e., data) and do not have custom CRUD behavior. Such Kinds are automatically managed by CKG and stored in the KindDB, where it will be indexed for efficient search and querying (including sophisticated entity cooccurrences).\n\n\nServices also \ndepend\n on \nexisting\n \nKinds\n and \nqueries\n, \nmutations\n, and \nevents\n. The services that provide these Kinds (which may be fully managed by CKG/KindDB) can be \nimported\n into a new service purely through GraphQL and specified in a \nmanifest\n that is used to \ncreate and register\n a new service. This process will result in a \nmerged schema\n on a \nservice-specific endpoint\n that the newly developed service uses for \nall\n Maana GraphQL communication (non-pub/sub).\n\n\nDevelopment Stages\n\n\n\n\nDesign:\n focus on GraphQL types (\nKinds\n, \nProperties\n, \nRelations\n), queries and mutations (often based on \nProblem Questions\n), and events (consumed and produced)\n\n\nLocal Service (Standalone)\n: choose programming language, identify dependencies (libraries, existing services and domain models), core logic to satisfy GraphQL interface contract\n\n\nLocal Service\n (\nMaana)\n: continue local development, connecting to a \nremote\n Maana deployment (e,g, Azure) to consume and produce GraphQL other services via your \ncustom endpoint\n\n\nUnmanaged Service\n: deploy your service via your own means (e.g., Heroku), but make it accessible to Maana to communicate to for call and event dispatching\n\n\nManaged Service\n: Dockerize your service and make it available in a registry that Maana has access to (e.g., Azure)\n\n\n\n\nThe following sections will elaborate on each of these stages.\n\n\nStage: Design\n\n\nAt this point, the overall problem to be solved has been analyzed and a \ndomain model\n and set of \ndecomposed\n \nproblem questions\n has been generated, some discussion of \nentity sources\n and \ndata science\n has taken place, and it is now time to code one or more \nKnowledge Microservices\n to provide some new \nconcepts\n (types, Kinds) along with \nqueries\n, \nmutations\n, and \nevents\n that involve them.\n\n\nFocus on the GraphQL\n. This is the entire description of and interface to the \nworld\n for the Knowledge service/bot. Define the \nGraphQL SDL\n a file, e.g., `model.gql`, including custom queries, mutations, and publications/subscriptions. Plan the custom \nresolvers\n, i.e., what is their \ncore logic\n?\n\n\nStage: Local Service (Standalone)\n\n\nWith at least an initial design complete, the following implementation decisions must be made:\n\n\n\n\nAre there existing Kinds and Services that can be reused?\n\n\nAre their existing code libraries or ML models that can be reused?\n\n\nWhat is the best programming language for this task?\n\n\nIs there reference data or domain data?\n\n\nAre there long-running tasks?\n\n\nWhat are the scale, performance, and capacity factors?\n\n\n\n\nOnce a programming language has been chosen, then an \nexisting project template\n can be used to scaffold a new Knowledge Microservice/Bot in Scala/JVM, Python, JavaScript, ...\n\n\nDevelopment of core logic or machine learning solution happens as it normally would, writing, testing, and debugging code or improving model accuracy.\n\n\nThe Knowledge Service is a standard GraphQL endpoint, so it can be run and tested within the development environment and used via \nMaana CLI\n, its own exposed \nGraphiQL\n, a standalone \nGraphQL Playground\n, etc.\n\n\nDependent types and services are \nimported\n into the service \nmodel\n using a modified version of a technique from \ngraphql-import\n:\n\n\n# import File, Url, MimeType from io.maana.core @PASSTHRU\n\ninput CrawlOptions {\n  url: Url\n  ...\n}\n\n\n...\n\n\ntype Mutation {\n  crawl(input: CrawlOptions): BotAction\n  ...\n}\n\n\n\n\nStage: Local Service (Maana)\n\n\nIn the previous stage, it is likely that various calls/services were stubbed or mocked because they required accessing a Maana cluster. It is now time to interact with a Maana deployment, typically one dedicated to development.\n\n\nCommunication to a Maana system requires the use of authentication. This is configured differently, based on the language/framework being used. Refer to the project template documentation used to scaffold the Knowledge service project.\n\n\nThe service being development must be registered with Maana. This is typically done programmatically using the Maana CLI by specifying a \nmanifest\n that describes the service and its dependencies. For example:\n\n\n{\n  id: \"io.maana.azure.crawler\",\n  name: \"Maana Azure Storage Crawler Service\",\n  dockerRegistry: null,\n  hostedUrl: null,\n}\n\n\n\n\nThe result of registering a new service with Maana is that CKG will generate a dedicated service endpoint for the new service, e.g., \nhttps://knowledge.acme.com/service/io.maana.azure.crawler:7331.\n This enables the standalone service to communicate to Maana, but does not allow Maana to dispatch calls to the standalone service due to network connectivity restrictions. (This will be overcome in the next stages.)\n\n\nThe full GraphQL schema for a service manifest is:\n\n\n# from io.maana.system\ntype ServiceManifest {\n  id: ID!\n  name: String\n  description: Text\n  registeredOn: DateTime\n  registeredBy: User\n  dockerRegistry: Url\n  hostedUrl: Url\n  modelSdl: String\n}\n\n\n\n\nStage: Unmanaged Service\n\n\nWhen it is time to have full participation in the Maana processing network, i.e., having its endpoint services consumed by other services, user interfaces, or automatically based on event subscription, then Maana's CKG must be able to communicate to the service. This means that the service must itself be deployed to a host that is accessible from the Maana cluster, e.g., Heroku, Azure, AWS, on-premise. In this configuration, the service owner is responsible for deploying, monitoring, scaling, securing, etc. the service, since Maana only has knowledge of a GraphQL endpoint URL and the schema it provides.\n\n\nSee the \nDeploy to Heroku tutorial\n.\n\n\nStage: Managed Service\n\n\nMaana can completely manage a \ncontainerized\n Knowledge Microservice/Bot, by specifying a Docker registry that the Maana deployment has access to (e.g., DockerHub, Azure). The following additional information is required when configuring a service to be managed by Maana:\n\n\n\n\nscale stuff ??\n\n\n?? \nAndrey Batyuk\n\n\n\n\nDebugging a Knowledge Microservice\n\n\nAndrey Batyuk\n\n\nThe BotAction Protocol\n\n\nSee \ntechnical design note\n.\n\n\nKnowledge Applications\n\n\nSolution developers can develop knoweldge applications on top of the MAANA knwoledge graph.\n\n\n\n\nwho is the audience for the applications?\n\n\nSME and are looking for answers to specific questions (i.e. Given a ship, a ship route and an omitted port, what re-route options can be considered to minimize trip duration for the loads onboard?)\n\n\n\n\n\n\nwhat type of applications can be developed?\n\n\ncustom web apps, Power BI apps, Tableau, Spotfire? others?\n\n\n\n\n\n\nwhat are the steps to build an application?\n\n\nhow does a developer publish and manage/share/update/delete an app?\n\n\n\n\nDevelopment Environments\n\n\nVisual Studio Code\n\n\nMost people run the \n\"insiders\" edition\n to have access to latest features.\n\n\nCommand Line\n\n\nAdd VS Code to your path so you can invoke it from the command line\n\n\nexport PATH=\"$PATH:/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/bin\"\n\n\n\n\nThe 'code' command will now be available in your terminal.\n\n\nRecommended Plugins\n\n\ncode --install-extension PeterJausovec.vscode-docker\ncode --install-extension christian-kohler.npm-intellisense\ncode --install-extension christian-kohler.path-intellisense\ncode --install-extension dbaeumer.vscode-eslint\ncode --install-extension eamodio.gitlens\ncode --install-extension eg2.vscode-npm-script\ncode --install-extension esbenp.prettier-vscode\ncode --install-extension kumar-harsh.graphql-for-vscode\ncode --install-extension mikestead.dotenv\ncode --install-extension ms-azuretools.vscode-azurefunctions\ncode --install-extension ms-vscode.azure-account\ncode --install-extension msjsdiag.debugger-for-chrome\ncode --install-extension robertohuertasm.vscode-icons\n\n\n\n\nSettings\n\n\nAccess user settings from \"Code Insiders / Preferences / Settings\" and paste the following settings in the \"User Settings\" tab.\n\n\njson\n{\n    \"workbench.iconTheme\": \"vscode-icons\",\n    \"workbench.colorTheme\": \"Default High Contrast\",\n    \"editor.fontFamily\": \"'Roboto Mono Light For Powerline', Menlo, Monaco, 'Courier New', italic\",\n    \"editor.formatOnSave\": true,\n    \"editor.tabSize\": 2,\n    \"editor.insertSpaces\": true,\n    \"eslint.autoFixOnSave\": true,\n    \"files.associations\": {\n        \"*.js\": \"javascriptreact\"\n    },\n    \"explorer.confirmDragAndDrop\": false,\n    \"explorer.confirmDelete\": false,\n    \"window.zoomLevel\": 0,\n    \"gitlens.advanced.messages\": {\n        \"suppressCommitHasNoPreviousCommitWarning\": false,\n        \"suppressCommitNotFoundWarning\": false,\n        \"suppressFileNotUnderSourceControlWarning\": false,\n        \"suppressGitVersionWarning\": false,\n        \"suppressLineUncommittedWarning\": false,\n        \"suppressNoRepositoryWarning\": false,\n        \"suppressUpdateNotice\": false,\n        \"suppressWelcomeNotice\": true\n    },\n    \"search.exclude\": {\n        \"**/node_modules\": true,\n        \"**/.git\": true\n    },\n    \"git.autofetch\": true\n}\n\n\nSome of these are team style, some are personal preference (e.g., workbench.colorTheme).\n\n\nDocument generated by Confluence on Jul 25, 2018 06:05\n\n\nAtlassian\n\n\nWORD CONVERSION\n\n\nMAANA Q\n\n\nKnowledge Technology Development Guide\n\n\nTable of Contents\n\n\n\n\nPlatform Architecture and Components overview        1\n\n\n\n\n1.1.        What is MAANA?        1\n\n\n1.2.        Maana platform architecture and GraphQL        3\n\n\n1.3.        About Maana Kinds and other useful terms        4\n\n\n1.4.        Knowledge Microservices        5\n\n\n1.5.        Knowledge Applications        6\n\n\n1.6.        MAANA catalogue        7\n\n\n\n\n\n\nDefining a model in Maana        7\n\n\n\n\n\n\nHydrating the model with data        8\n\n\n\n\n\n\nQuerying a model        11\n\n\n\n\n\n\n4.1.        Query through service end points        11\n\n\n4.2.        Query using global entry points        11\n\n\n4.3.        Query using allinstances        12\n\n\n4.4.        Query across kinds        13\n\n\n\n\nDeveloping knowledge microservices        14\n\n\n\n\n5.1.        Project Setup        14\n\n\n5.2.        Development        15\n\n\n5.3.        Packaging        15\n\n\n5.4.        Adding a knowledge microservice to the MAANA catalogue        15\n\n\n\n\n\n\nDeveloping knowledge applications        16\n\n\n\n\n\n\nTroubleshooting        16\n\n\n\n\n\n\nTroubleshooting        16\n\n\n\n\n\n\nAudience for this guide: Solution Developers / Data Scientist\n\n\nThis guide helps Solution Developers and Data Scientists learn how to build Knowledge Solutions on the Maana platform .\n\n\n\n\n1.Platform Architecture and Components overview\n\n\n1.1.What is MAANA?\n\n\n\n\nIn 2013 Maana invented a new way to represent industrial knowledge mathematically, using the Maana Patented Computational Knowledge Graph\u2122. This unique technology enables industrial companies to encode human expertise and data from across silos into digital knowledge to help employees make better and faster decisions. The Maana Computational Knowledge Graph\u2122 is a network of models that optimize specific operations and decisions flows by providing recommendations through AI-Driven Applications into those operations. This unique technology eliminates the need to move data and enables creation of thousands of models at scale, through the re-usability of models across the enterprise.\n\n\nWhy MAANA\n\n\nThe core of the Maana Knowledge Platform\u2122 is its patented Computational Knowledge Graph\u2122. The Maana Knowledge Graph is unique in several ways:\n\n\n\n\n\n\nUnlike traditional \"semantic\" systems, the Knowledge Graph does not rely exclusively on ontologies and description logics. Instead, the Knowledge Graph separates the structure of data from the content itself. This separation enables a fluidity of modeling, allowing data from any source and in any format to be seamlessly integrated, modeled, searched, analyzed, operationalized and re-purposed.\n\n\n\n\n\n\nThe data remains at the source and only the most relevant data in the context of what is being optimized is indexed and brought into the graph.\n\n\n\n\n\n\nEach resulting model is a unique combination of three key components \u2013 subject matter expertise, relevant data from silos, and the right algorithm \u2013 all of which are instrumental in optimizing assets and decision flows.\n\n\n\n\n\n\nThe Maana Computational Knowledge Graph is also dynamic. Nodes, which represent concepts in Maana's graph are not static containers; they are computational vessels that allow for algorithms to be stored and executed. These algorithms could be as simple as pulling in new data from an external source, to as complicated as classification of documents through machine learning. As data is updated in real-time at the source, so are the nodes and the computational models that act on that data. This\n\n\n\n\n\n\nallows for far more complex relationships to be modeled, and facilitates the ability of the graph to understand the connections between concepts, rather than just strings in data. Ultimately this is used for optimizing decisions or operations.\n\n\n\n\nReusable Models\n\n\n\n\nThe flexibility of the Maana Knowledge Graph enables groups across the organization to leverage and build-upon models created by other groups, dramatically accelerating the speed at which models are created throughout the organization. These models are dynamic, and once operationalized into line-of-business applications, they learn and adapt based on the user's behaviors and provide continuous intelligence for day-to-day operations.\n\n\nThe Maana Computational Knowledge Graph\u2122 at the core of the platform is a network of models that are built using machine learning techniques and artificial intelligence that power AI-Driven Applications used to digitize decision support and operations.\n\n\nIt allows the knowledge of the business to be incrementally captured and grown, becoming more sophisticated as more projects are developed using it.\n\n\nThe MAANA knowledge platform offers a new way to get more out of machine learning and artificial intelligence projects and is the fastest way to digitize your business.\n\n\n1.\n  1. 1.2.Maana platform architecture and GraphQL\n\n\nMaana platform architecture\n\n\n\n\nInsert paragraph on Maana platform architecture components \u2013 ask Donald where can you get the content from.\n\n\nMAANA platform is using GraphQL, a query language for APIs and a runtime for fulfilling queries with data. GraphQL provides a complete and understandable description of the data in the API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.\n\n\nWith the GraphQL type system, the developers can access the full capabilities of your data from a single endpoint.\n\n\nGraphQL creates a uniform API across your entire application without being limited by a specific storage engine. The developer provides functions for each field in the type system, and GraphQL calls them with optimal concurrency.\n\n\n1.\n  1. 1.3.About Maana Kinds and other useful terms\n\n\nBefore creating a working computational knowledge graph and, it is useful to gain a basic understanding of a few notions that will help the user make most out of the MAANA portal experience.\n\n\n\n\n\n\n\n\nTerm\n\n\nWhat is it?\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nKinds   \n\n\nKinds are concepts.\n\n\nExamples: People, Ships, Oil Wells, Invoices\n\n\n\n\n\n\nFields\n\n\nFields are properties within a certain concept\n\n\nExamples of fields related to the People concept: age, sex, height, weight, etc.do we need this?\n\n\n\n\n\n\nInstances\n\n\nA particular set of values for entities within a concept.\n\n\nExample of an instance: Paul, 40yrs old, male, 6', 180poundsExamples of entities related to the People concept: age, sex, height, weight, etc.\n\n\n\n\n\n\nValues\n\n\nA particular size, measure, number of an entity\n\n\nExample of a value: 40Example of an instance: Paul, 40yrs old, male, 6', 180pounds\n\n\n\n\n\n\nRelations\n\n\nConnections /dependencies that can be established between fields belonging to different Kinds\n\n\nExample: A Kind describing an oil well may contain a field of type String showing the name of the company operating that well. That field has a relation with the Kind containing Company Names\n\n\n\n\n\n\n\n\n1.\n  1. 1.4.Knowledge Microservices\n\n\nKnowledge microservices are a class of microservices that are developed for the MAANA platform.\n\n\nMaana Knowledge Services form a network of GraphQL endpoints, exposing their types, queries, and mutations for direct access, as well as publishing and subscribing to network events.  The Maana platform manages these services, providing authentication, reliable messaging, (automatic) graph persistence (with search and querying), scaling, monitoring, and a rich UX.\n\n\nExamples of knowledge microservices include:\n\n\n\n\n\n\n\n\nIndexers\n \u2022 Text\u2022 Number\u2022 Time\u2022 Geospatial\u2022 Geometric\n\n\nMiners\n \u2022 Statistics\u2022 Probabilities\u2022 NER/NLP\n\n\nClassifiers\n \u2022 Entity\u2022 Field\u2022 Document\u2022 Image\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKnowledge Services can become Knowledge \"Bots\" by offering and using \"bot actions,\" which allows the service to interact more directly to users.\n\n\nUsers can configure, start, stop, and schedule bot actions.  Services can report on status and progress for potentially long-running, asynchronous operations, as well as report any errors or messages. Bots are microservices that \"listen\" for specific events on a system bus \u2013 Maana uses RabbitMQ for system bus \u2013 and act automatically when such events happen to mine and enrich the graph (i.e. when a raw data file is loaded into MAANA, a bot automatically analyzes it to identify mentions of entities like persons, phone numbers, values, and facts).\n\n\nThere are two primary scenarios to consider here: event handling and direct query/mutation.\n\n\n\n\nEvent Handling\n\n\n\n\nWhen a Knowledge Service subscribes to and handles an event, such as \"fileAdded,\" it can (optionally) create an instance of a BotAction Kind by mutating the CKG.  As the service performs its operation, it can periodically update the progress (if it is deterministic) and update the status and report errors.\n\n\n\n\nQueries and Mutations\n\n\n\n\nA user can invoke a query or mutation either explicitly (e.g., train a classifier on labeled data) or implicitly (i.e., as part of query graph).  In such cases, the service exposes such queries and mutations as returning a BotAction.\n\n\n1.\n  1. 1.5.Knowledge Applications\n\n\nKnowledge Applications are applications that are built on top of the Maana CKG to help subject matter experts make better decisions faster.\n\n\nA Knowledge application presents a custom interface to the end user and optimizes interaction for most common actions.\n\n\nGenerally a knowledge application generally provides the following functionality:\n\n\n\n\nAllow user to specify question inputs\n\n\nGenerate recommendations\n\n\nVisualize recommendations and rationale\n\n\nAllow user to explore and tune inputs\n\n\nAccept user decision\n\n\n\n\nKnowledge applications can be developed in any language. Most languages have some level of GraphQL support.\n\n\n1.\n  1. 1.6.MAANA catalogue\n\n\nMaana catalogue is the repository for all components that can be used as part of MAANA knowledge solutions\n\n\n\n\n\n\nHow do you add/publish/update/delete components in the catalogue?\n\n\n\n\n\n\n2.Defining a model in Maana\n\n\n\n\n\n\nAll of the following documentation uses XXX.XXX.XXX.XXX facing to represent the public URL of the system. All of the following examples use the Graphiql endpoint which is interactive, programmatic access conducted through the Graphql endpoint.\n\n\nGraphQL API is organized around three main building blocks: the schema, queries, and resolvers.\n\n\nQueries can be executed via GET or POST, with either the body of the query as the query string or in the body of the POST. All mutations must use the POST endpoint and have the header content type set to application/json. Also, the GraphQL server needs a resolver to know what to do with an incoming query.\n\n\n\n\n    _Anatomy of a GraphQL Query (_ [_source_](https://dev-blog.apollodata.com/the-anatomy-of-a-graphql-query-6dffa9e9e747)_)_\n\n\n\nThe following is an example of how to create a graph with no mutation specified, using the cURL command line tool for getting or sending files using URL syntax.\n\n\ncurl -v -H \"Content-Type: application/json\" -X POST -d \"{\\\"query\\\": \\\"mutation { ..... }\\\"}\" http://XXX.XXX.XXX.XXX:8003/graphql\n\n\nMaana engineering team is currently implementing authentication functionality, which will be required for all clients.\n\n\n\n\nHow to create a graph from a GQL definition ( \nhttps://confluence.corp.maana.io/display/RD/Maana+Q+programmatic+interface\n)\n\n\nHow to add instance data\n\n\nHow to query instance data\n\n\nHow to perform complex queries ( \nhttps://confluence.corp.maana.io/display/RD/Technical+Design+Notes#TechnicalDesignNotes-Queries\n)\n\n\n\n\nHow to perform search ( \nhttps://confluence.corp.maana.io/display/RD/Maana+Q+Search+-+Technical+Design\n)\n\n\n\n\n\n\n3.Hydrating the model with data\n\n\n\n\n\n\nSteps to hydrate a model with data:\n\n\n\n\nCreate a service source with graphql schema\n. Types must correspond to Kinds on the portal endpoint XXX.XXX.XXX.XXX:8003/graphiql. Note that the service can have many Kind definitions.\n\n\n\n\nmutation {\n\n\naddServiceSource(input: {\n\n\nname: &quot;TestService&quot;,\n\nschema: &quot;type TestKind { \\n id: ID \\n name: String! \\n something: Int! }&quot;\n\n\n\n})\n\n\n}\n\n\nCreating a Service Source will return a Service ID:\n\n\n{\n\n\n\"data\": {\n\n\n&quot;addServiceSource&quot;: &quot;54769aae-2c63-4415-9b34-74e9ceb1d789&quot;\n\n\n\n}\n\n\n}\n\n\nThis ID is used to establish the Service endpoint for subsequent interactions\n\n\nXXX.XXX.XXX.XXX:8003/service/54769aae-2c63-4415-9b34-74e9ceb1d789/graphiql\n\n\nNote: If the service is re-created by updating definitions, its service ID will change, while the old service will still be available.\n\n\n\n\nAdding a single instance of the kind\n\n\n\n\nmutation {\n\n\naddTestKind(input: {\n\n\nname: &quot;testname&quot;,\n\nsomething: 42\n\n\n\n})\n\n\n}\n\n\nAn ID is assigned and returned for the instance itself\n\n\n{\n\n\n\"data\": {\n\n\n&quot;addTestKind&quot;: &quot;431f9338-95be-4f89-968c-4f2bb197965c&quot;\n\n\n\n}\n\n\n}\n\n\nOnce the instance data was added, we can query it using:\n\n\nquery {\n\n\nallTestKinds {\n\n\nid\n\nname\n\nsomething\n\n\n\n}\n\n\n}\n\n\n\n\nAdding multiple data instances simultaneously to a kind\n\n\n\n\nmutation addSomethings {\n\n\naddTestKinds(input: [{\n\n\nname: &quot;testname2&quot;,\n\nsomething: 45\n\n\n\n}, {\n\n\nname: &quot;testname3&quot;,\n\nsomething: 43\n\n\n\n}\n\n\n])\n\n\n}\n\n\nLarger data volumes should be broken into reasonably sized chunks (i.e. up to 5,000 instances), and submitted sequentially through the endpoint.\n\n\nData can be queried using:\n\n\nquery {\n\n\nallTestKinds {\n\n\nid\n\nname\n\nsomething\n\n\n\n}\n\n\n}\n\n\n\n\n4.Querying a model\n\n\n\n\n1.\n  1. 4.1.Query through service end points\n\n\nThis is the most common way to query the data once ingested in the graph\n\n\nquery {\n\n\nallTestKinds {\n\n\nid\n\nname\n\nsomething\n\n\n\n}\n\n\n}\n\n\n1.\n  1. 4.2.Query using global entry points\n\n\nThere are more generic ways to read Kinds from a model than through service entry points.\n\n\nHowever when using the global entry points (rather than the service entry points), Kinds should be referenced by ID. The IDs for each kind can be obtained from the Service ID by running a query against XXX.XXX.XXX.XXX:8003\n\n\nHere is an example on how to obtain a Kind IDs from the Service ID:\n\n\nquery foo {\n\n\nserviceSource(id:\"54769aae-2c63-4415-9b34-74e9ceb1d789\") {\n\n\nname\n\nkinds {\n\n  name\n\n  id\n\n}\n\n\n\n}\n\n\n}\n\n\nThe query above should return\n\n\n{\n\n\n\"data\": {\n\n\n&quot;serviceSource&quot;: {\n\n  &quot;name&quot;: &quot;TestService&quot;,\n\n  &quot;kinds&quot;: [\n\n    {\n\n      &quot;name&quot;: &quot;54769aae-2c63-4415-9b34-74e9ceb1d789\\_TestKind&quot;,\n\n      &quot;id&quot;: &quot;a745e4d7-74e9-4023-8f39-bc63d6076326&quot;\n\n    }\n\n  ]\n\n}\n\n\n\n}\n\n\n}\n\n\n1.\n  1. 4.3.Query using allinstances\n\n\nThis type of query can be used to get instances for a kind in the same format as the query entry point:\n\n\nquery {\n\n\nallInstances(tenantId:0, kindId:\"a745e4d7-74e9-4023-8f39-bc63d6076326\") {\n\n\nrecords {\n\n  STRING\n\n  ID\n\n}\n\n\n\n}\n\n\n}\n\n\n1.\n  1. 4.4.Query across kinds\n\n\nMore complex queries can be used to more efficiently query across kinds. Many internal services can use this endpoint to reduce the number of DB requests required to fulfil a request.\n\n\nHere is an example:\n\n\nquery {\n\n\nkindDBQuery(kindQuery:{\n\n  kindId:&quot;fcd39416-337c-4566-b5bf-56cc8ff725d2&quot;\n\n  fieldFilters: [{\n\n    op: &quot;==&quot;\n\n    fieldName: &quot;State&quot;\n\n    value: {\n\n      STRING:&quot;WA&quot;\n\n    }\n\n  }]\n\n  and: [{\n\n    kindId:&quot;fcd39416-337c-4566-b5bf-56cc8ff725d2&quot;\n\n    toFieldName:&quot;City&quot;\n\n    fromFieldName: &quot;City&quot;\n\n    fieldFilters:[{\n\n      op: &quot;==&quot;\n\n      fieldName: &quot;Zipcode&quot;\n\n      value: {\n\n        STRING: &quot;98053&quot;\n\n      }\n\n    }]\n\n  }]\n\n}) {\n\n  records {\n\n    ID\n\n    STRING\n\n    INT\n\n    FLOAT\n\n}\n\n\n\n}\n\n\n}\n\n\nThe outer most kind is the type returned, while inner kinds form a DAG where each inner kind constrains its outer kinds instances. The DAG should be considered to be a graph walk, where constraints are applied at each step in the walk, data is returned only if all constraints are true.\n\n\nFilters are a collection of {op, fieldname, value} triples that constrain the Kind on which they are applied.\n\n\nOperators that can be used:\n\n\n\n\nfor Strings : \"==\" , \"!=\" , \"oneof\"\n\n\n\n\nfor Numbers (Int and Float) :  \"<\", \"<=\", \">\", \">=\"\n\n\n\n\n\n\n5.Developing knowledge microservices\n\n\n\n\n5.1.Project Setup\n\n\n\n\nstart with a project template in your preferred language\n\n\nfollow the instructions on customizing it\n\n\nMaana Knowledge Service Templates\n\n\nIn an attempt to develop best-practices, code base coherence (learn once), and to ease maintenance burden, we've tried to standardize a number of things that a productive developer should not have to worry about and instead focus on adding real features.\n\n\nEvery project should follow a common, consistent pattern in order to reduce the tax imposed by infrastructure, such as web services and middleware, GraphQL services, logging, build, deployment, etc. As such, we recommend always  \ncloning\n a new project from the  \nMaana Knowledge Service template\n for your preferred language.\n\n\nOnce cloned, perform the customizations recommended in the template's README.md.\n\n\nIf your language isn't represented, we'd be happy to work with you to develop a template or just send a pull request to have it included.\n\n\n1.\n  1. 5.2.Development\n\n\n\n\ndefine GraphQL schema for the service endpoint\n\n\nimplement appropriate resolvers\n\n\nbe client (query, mutate, subscribe) to other Knowledge Services (dependencies)\n\n\nstitch together existing services, providing an aggregated endpoint (to simplify client access)\n\n\n\n\n1.\n  1. 5.3.Packaging\n\n\nprepare deployment\n\n\nmanaged service\n : create a docker container\n\n\nunmanaged service\n : not our problem\n\n\n1.\n  1. 5.4.Adding a knowledge microservice to the MAANA catalogue\n\n\n\n\nprepare a service manifest (basically a serialized instance of Kind Service)\n\n\nregister the service in the catalog\n\n\n\n\nMaana will:\n\n\nintrospect the service\n\n\ncreate all the Kinds in KindDB\n\n\nalong with boilerplate for  \nManaged Kinds\n\n\nthis includes types, queries, mutations, and subscriptions\n\n\nregister with CKG?\n\n\nboilerplate query and mutation resolvers and event emitters\n\n\nschema stitching between synthetic and service-provided resolvers\n\n\n\n\n\n\n\n\nDeveloping knowledge applications\n\n\n\n\n\n\n\n\n7.Troubleshooting\n\n\n\n\n\n\n8.Troubleshooting\n\n\n\n\n\n\nDevelopment Scenarios\n\n\nlocal: configure and run a local docker machine Maana system and custom services (i.e., a \"deployment\")\n\n\nthis is how the Maana R&D work\n\n\nemote: mixed environments - a Maana deployment is hosted elsewhere (e,g, Azure) and developing a service locally\n\n\nnot supported in v3.0?\n\n\nif local and developing an a (locally) deployed service, then \"docker stop\" it and run/debug it manually\n\n\nProject Setup\n\n\nstart with a project template in your preferred language\n\n\nfollow the instructions on customizing it\n\n\nDevelop\n\n\ndefine GraphQL schema for the service endpoint\n\n\nimplement appropriate resolvers\n\n\nbe client (query, mutate, subscribe) to other Knowledge Services (dependencies)\n\n\nstitch together existing services, providing an aggregated endpoint (to simplify client access)\n\n\nPackage\n\n\nprepare deployment\n\n\nmanaged service\n : create a docker container\n\n\nunmanaged service\n : not our problem\n\n\nCatalog\n\n\nprepare a service manifest (basically a serialized instance of Kind Service)\n\n\nregister the service in the catalog\n\n\nMaana will:\n\n\nintrospect the service\n\n\ncreate all the Kinds in KindDB\n\n\nalong with boilerplate for  \nManaged Kinds\n\n\nthis includes types, queries, mutations, and subscriptions\n\n\nregister with CKG?\n\n\nboilerplate query and mutation resolvers and event emitters\n\n\nschema stitching between synthetic and service-provided resolvers",
            "title": "Developer"
        },
        {
            "location": "/developer/#research-and-development-developer-guide",
            "text": "Created by Marius Marcu, last modified by Donald Thompson on Jul 12, 2018  Old Word Doc:  OLD Developer Guide OLD  Document name  Audience  Description  Knowledge Technology Development Guide  Solution Engineers and Data Scientists  details the architecture of the platform, how to build a full solution and/or reusable components",
            "title": "Research and Development : Developer Guide"
        },
        {
            "location": "/developer/#table-of-contents",
            "text": "/ <![CDATA[ / div.rbtoc1532523907698 {padding: 0px;} div.rbtoc1532523907698 ul {list-style: disc;margin-left: 0px;} div.rbtoc1532523907698 li {margin-left: 0px;padding-left: 0px;} / ]]> /   Table of Contents  Introduction  GraphQL and Microservices  GraphQL Learning Resources    Knowledge Microservices and Bots  Development Stages  Stage: Design  Stage: Local Service (Standalone)  Stage: Local Service (Maana)  Stage: Unmanaged Service  Stage: Managed Service    Debugging a Knowledge Microservice  The BotAction Protocol    Knowledge Applications  Development Environments  Visual Studio Code  Command Line  Recommended Plugins  Settings",
            "title": "Table of Contents"
        },
        {
            "location": "/developer/#introduction",
            "text": "The Maana platform is built from a network of  GraphQL -based  microservices . Unlike pure client-server or n-tier architectures, Maana's microservices act as peers in an asynchronous and loosely-coupled arrangement that promotes independent scaling and extensibility. These services provide identity and access controls, graph persistence, search, machine learning, and natural language processing. Ultimately, these services provide reasoning capabilities to Knowledge Applications, which help solve domain-specific problems and support optimal decision-making capable of learning over time.  This guide is intended for Solution Developers and Data Scientists and describes how to develop such services (aka \"bots\") and applications and operationalize them in a production setting.",
            "title": "Introduction"
        },
        {
            "location": "/developer/#graphql-and-microservices",
            "text": "At the core of any Maana solution sits a Knowledge Graph, which consists of  concepts  and  properties ,  instances  and  values , and  relations  and  links . For example, consider the concept of a  ContainerShip  with properties  name ,  length ,  position , etc. A specific instance (entity) has values for each of the properties, such as the Maersk Viking with a length of  400 meters , ... Such properties can be  scalar  (e.g., numbers, strings, dates) or might refer to other concepts/instances, e.g., ships  hold Cargo . In some cases, property values for an instance are simply stored, since they don't change (often). In other cases, they are dynamically computed, such as a ship's  weight  (which depends on its cargo) or its  current position  (which requires getting a GPS reading).  GraphQL  is a data query language created by Facebook and open-sourced in 2015 as an alternative to REST interfaces. Maana uses GraphQL to represent and expose its Knowledge Graph  Unlike a traditional  graph database , Maana incorporate arbitrary computation (through custom GraphQL resolvers) and distributes the graph into subgraphs managed by different  microservices , optionally with their own dedicated persistence mechanism.  While this approach allows for flexibility, it places more responsibility on the microservices to provide their own storage. To address this, Maana proposes an explicit split between the data models (i.e., GraphQL type definitions) that a service uses and its operations (i.e., GraphQL resolvers). Maana will generate the appropriate managed service for such models using  KindDB , Prisma, neo4j, ... The solution developer, then, only provides the logic they care about and let the system take care of all the CRUD/ORM-like operations on the data.  The  Computational Knowledge Graph (CKG) , itself a microservice, provides automatic persistence, boilerplate queries and mutations, and service orchestration capabilities. Taken together, these service allow the solution developer to focus on  designing GraphQL schemas  and implementing  computational resolvers  only where needed.",
            "title": "GraphQL and Microservices"
        },
        {
            "location": "/developer/#graphql-learning-resources",
            "text": "How to GraphQL",
            "title": "GraphQL Learning Resources"
        },
        {
            "location": "/developer/#knowledge-microservices-and-bots",
            "text": "A  GraphQL service  (endpoint) consists of:   types  queries  mutations  events  (pub/sub)   A  Knowledge Microservice  is a GraphQL service that also includes:   authenticated access  client/server boilerplate  reliable messaging using RabbitMQ  lifecycle management (info, register, deregister)  Docker containerization and automatic scaling/load balancing   A  Bot  is a Knowledge Microservice that provides specialized queries and mutations that perform  BotActions , which allow the bot to provide asynchronous status updates. This enables user interface components to reflect the latest status of  long-running operations  or  automatically triggered events , e.g., entity recognition, new concept creation, classification.  All  Kinds  (concepts, types) are associated with a service. This service is said to  provide  the (entities of) the Kind. Many Kinds are purely extensional (i.e., data) and do not have custom CRUD behavior. Such Kinds are automatically managed by CKG and stored in the KindDB, where it will be indexed for efficient search and querying (including sophisticated entity cooccurrences).  Services also  depend  on  existing   Kinds  and  queries ,  mutations , and  events . The services that provide these Kinds (which may be fully managed by CKG/KindDB) can be  imported  into a new service purely through GraphQL and specified in a  manifest  that is used to  create and register  a new service. This process will result in a  merged schema  on a  service-specific endpoint  that the newly developed service uses for  all  Maana GraphQL communication (non-pub/sub).",
            "title": "Knowledge Microservices and Bots"
        },
        {
            "location": "/developer/#development-stages",
            "text": "Design:  focus on GraphQL types ( Kinds ,  Properties ,  Relations ), queries and mutations (often based on  Problem Questions ), and events (consumed and produced)  Local Service (Standalone) : choose programming language, identify dependencies (libraries, existing services and domain models), core logic to satisfy GraphQL interface contract  Local Service  ( Maana) : continue local development, connecting to a  remote  Maana deployment (e,g, Azure) to consume and produce GraphQL other services via your  custom endpoint  Unmanaged Service : deploy your service via your own means (e.g., Heroku), but make it accessible to Maana to communicate to for call and event dispatching  Managed Service : Dockerize your service and make it available in a registry that Maana has access to (e.g., Azure)   The following sections will elaborate on each of these stages.",
            "title": "Development Stages"
        },
        {
            "location": "/developer/#stage-design",
            "text": "At this point, the overall problem to be solved has been analyzed and a  domain model  and set of  decomposed   problem questions  has been generated, some discussion of  entity sources  and  data science  has taken place, and it is now time to code one or more  Knowledge Microservices  to provide some new  concepts  (types, Kinds) along with  queries ,  mutations , and  events  that involve them.  Focus on the GraphQL . This is the entire description of and interface to the  world  for the Knowledge service/bot. Define the  GraphQL SDL  a file, e.g., `model.gql`, including custom queries, mutations, and publications/subscriptions. Plan the custom  resolvers , i.e., what is their  core logic ?",
            "title": "Stage: Design"
        },
        {
            "location": "/developer/#stage-local-service-standalone",
            "text": "With at least an initial design complete, the following implementation decisions must be made:   Are there existing Kinds and Services that can be reused?  Are their existing code libraries or ML models that can be reused?  What is the best programming language for this task?  Is there reference data or domain data?  Are there long-running tasks?  What are the scale, performance, and capacity factors?   Once a programming language has been chosen, then an  existing project template  can be used to scaffold a new Knowledge Microservice/Bot in Scala/JVM, Python, JavaScript, ...  Development of core logic or machine learning solution happens as it normally would, writing, testing, and debugging code or improving model accuracy.  The Knowledge Service is a standard GraphQL endpoint, so it can be run and tested within the development environment and used via  Maana CLI , its own exposed  GraphiQL , a standalone  GraphQL Playground , etc.  Dependent types and services are  imported  into the service  model  using a modified version of a technique from  graphql-import :  # import File, Url, MimeType from io.maana.core @PASSTHRU\n\ninput CrawlOptions {\n  url: Url\n  ...\n}\n\n\n...\n\n\ntype Mutation {\n  crawl(input: CrawlOptions): BotAction\n  ...\n}",
            "title": "Stage: Local Service (Standalone)"
        },
        {
            "location": "/developer/#stage-local-service-maana",
            "text": "In the previous stage, it is likely that various calls/services were stubbed or mocked because they required accessing a Maana cluster. It is now time to interact with a Maana deployment, typically one dedicated to development.  Communication to a Maana system requires the use of authentication. This is configured differently, based on the language/framework being used. Refer to the project template documentation used to scaffold the Knowledge service project.  The service being development must be registered with Maana. This is typically done programmatically using the Maana CLI by specifying a  manifest  that describes the service and its dependencies. For example:  {\n  id: \"io.maana.azure.crawler\",\n  name: \"Maana Azure Storage Crawler Service\",\n  dockerRegistry: null,\n  hostedUrl: null,\n}  The result of registering a new service with Maana is that CKG will generate a dedicated service endpoint for the new service, e.g.,  https://knowledge.acme.com/service/io.maana.azure.crawler:7331.  This enables the standalone service to communicate to Maana, but does not allow Maana to dispatch calls to the standalone service due to network connectivity restrictions. (This will be overcome in the next stages.)  The full GraphQL schema for a service manifest is:  # from io.maana.system\ntype ServiceManifest {\n  id: ID!\n  name: String\n  description: Text\n  registeredOn: DateTime\n  registeredBy: User\n  dockerRegistry: Url\n  hostedUrl: Url\n  modelSdl: String\n}",
            "title": "Stage: Local Service (Maana)"
        },
        {
            "location": "/developer/#stage-unmanaged-service",
            "text": "When it is time to have full participation in the Maana processing network, i.e., having its endpoint services consumed by other services, user interfaces, or automatically based on event subscription, then Maana's CKG must be able to communicate to the service. This means that the service must itself be deployed to a host that is accessible from the Maana cluster, e.g., Heroku, Azure, AWS, on-premise. In this configuration, the service owner is responsible for deploying, monitoring, scaling, securing, etc. the service, since Maana only has knowledge of a GraphQL endpoint URL and the schema it provides.  See the  Deploy to Heroku tutorial .",
            "title": "Stage: Unmanaged Service"
        },
        {
            "location": "/developer/#stage-managed-service",
            "text": "Maana can completely manage a  containerized  Knowledge Microservice/Bot, by specifying a Docker registry that the Maana deployment has access to (e.g., DockerHub, Azure). The following additional information is required when configuring a service to be managed by Maana:   scale stuff ??  ??  Andrey Batyuk",
            "title": "Stage: Managed Service"
        },
        {
            "location": "/developer/#debugging-a-knowledge-microservice",
            "text": "Andrey Batyuk",
            "title": "Debugging a Knowledge Microservice"
        },
        {
            "location": "/developer/#the-botaction-protocol",
            "text": "See  technical design note .",
            "title": "The BotAction Protocol"
        },
        {
            "location": "/developer/#knowledge-applications",
            "text": "Solution developers can develop knoweldge applications on top of the MAANA knwoledge graph.   who is the audience for the applications?  SME and are looking for answers to specific questions (i.e. Given a ship, a ship route and an omitted port, what re-route options can be considered to minimize trip duration for the loads onboard?)    what type of applications can be developed?  custom web apps, Power BI apps, Tableau, Spotfire? others?    what are the steps to build an application?  how does a developer publish and manage/share/update/delete an app?",
            "title": "Knowledge Applications"
        },
        {
            "location": "/developer/#development-environments",
            "text": "",
            "title": "Development Environments"
        },
        {
            "location": "/developer/#visual-studio-code",
            "text": "Most people run the  \"insiders\" edition  to have access to latest features.",
            "title": "Visual Studio Code"
        },
        {
            "location": "/developer/#command-line",
            "text": "Add VS Code to your path so you can invoke it from the command line  export PATH=\"$PATH:/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/bin\"  The 'code' command will now be available in your terminal.",
            "title": "Command Line"
        },
        {
            "location": "/developer/#recommended-plugins",
            "text": "code --install-extension PeterJausovec.vscode-docker\ncode --install-extension christian-kohler.npm-intellisense\ncode --install-extension christian-kohler.path-intellisense\ncode --install-extension dbaeumer.vscode-eslint\ncode --install-extension eamodio.gitlens\ncode --install-extension eg2.vscode-npm-script\ncode --install-extension esbenp.prettier-vscode\ncode --install-extension kumar-harsh.graphql-for-vscode\ncode --install-extension mikestead.dotenv\ncode --install-extension ms-azuretools.vscode-azurefunctions\ncode --install-extension ms-vscode.azure-account\ncode --install-extension msjsdiag.debugger-for-chrome\ncode --install-extension robertohuertasm.vscode-icons",
            "title": "Recommended Plugins"
        },
        {
            "location": "/developer/#settings",
            "text": "Access user settings from \"Code Insiders / Preferences / Settings\" and paste the following settings in the \"User Settings\" tab.  json\n{\n    \"workbench.iconTheme\": \"vscode-icons\",\n    \"workbench.colorTheme\": \"Default High Contrast\",\n    \"editor.fontFamily\": \"'Roboto Mono Light For Powerline', Menlo, Monaco, 'Courier New', italic\",\n    \"editor.formatOnSave\": true,\n    \"editor.tabSize\": 2,\n    \"editor.insertSpaces\": true,\n    \"eslint.autoFixOnSave\": true,\n    \"files.associations\": {\n        \"*.js\": \"javascriptreact\"\n    },\n    \"explorer.confirmDragAndDrop\": false,\n    \"explorer.confirmDelete\": false,\n    \"window.zoomLevel\": 0,\n    \"gitlens.advanced.messages\": {\n        \"suppressCommitHasNoPreviousCommitWarning\": false,\n        \"suppressCommitNotFoundWarning\": false,\n        \"suppressFileNotUnderSourceControlWarning\": false,\n        \"suppressGitVersionWarning\": false,\n        \"suppressLineUncommittedWarning\": false,\n        \"suppressNoRepositoryWarning\": false,\n        \"suppressUpdateNotice\": false,\n        \"suppressWelcomeNotice\": true\n    },\n    \"search.exclude\": {\n        \"**/node_modules\": true,\n        \"**/.git\": true\n    },\n    \"git.autofetch\": true\n}  Some of these are team style, some are personal preference (e.g., workbench.colorTheme).  Document generated by Confluence on Jul 25, 2018 06:05  Atlassian",
            "title": "Settings"
        },
        {
            "location": "/developer/#word-conversion",
            "text": "MAANA Q  Knowledge Technology Development Guide  Table of Contents   Platform Architecture and Components overview        1   1.1.        What is MAANA?        1  1.2.        Maana platform architecture and GraphQL        3  1.3.        About Maana Kinds and other useful terms        4  1.4.        Knowledge Microservices        5  1.5.        Knowledge Applications        6  1.6.        MAANA catalogue        7    Defining a model in Maana        7    Hydrating the model with data        8    Querying a model        11    4.1.        Query through service end points        11  4.2.        Query using global entry points        11  4.3.        Query using allinstances        12  4.4.        Query across kinds        13   Developing knowledge microservices        14   5.1.        Project Setup        14  5.2.        Development        15  5.3.        Packaging        15  5.4.        Adding a knowledge microservice to the MAANA catalogue        15    Developing knowledge applications        16    Troubleshooting        16    Troubleshooting        16    Audience for this guide: Solution Developers / Data Scientist  This guide helps Solution Developers and Data Scientists learn how to build Knowledge Solutions on the Maana platform .   1.Platform Architecture and Components overview  1.1.What is MAANA?   In 2013 Maana invented a new way to represent industrial knowledge mathematically, using the Maana Patented Computational Knowledge Graph\u2122. This unique technology enables industrial companies to encode human expertise and data from across silos into digital knowledge to help employees make better and faster decisions. The Maana Computational Knowledge Graph\u2122 is a network of models that optimize specific operations and decisions flows by providing recommendations through AI-Driven Applications into those operations. This unique technology eliminates the need to move data and enables creation of thousands of models at scale, through the re-usability of models across the enterprise.  Why MAANA  The core of the Maana Knowledge Platform\u2122 is its patented Computational Knowledge Graph\u2122. The Maana Knowledge Graph is unique in several ways:    Unlike traditional \"semantic\" systems, the Knowledge Graph does not rely exclusively on ontologies and description logics. Instead, the Knowledge Graph separates the structure of data from the content itself. This separation enables a fluidity of modeling, allowing data from any source and in any format to be seamlessly integrated, modeled, searched, analyzed, operationalized and re-purposed.    The data remains at the source and only the most relevant data in the context of what is being optimized is indexed and brought into the graph.    Each resulting model is a unique combination of three key components \u2013 subject matter expertise, relevant data from silos, and the right algorithm \u2013 all of which are instrumental in optimizing assets and decision flows.    The Maana Computational Knowledge Graph is also dynamic. Nodes, which represent concepts in Maana's graph are not static containers; they are computational vessels that allow for algorithms to be stored and executed. These algorithms could be as simple as pulling in new data from an external source, to as complicated as classification of documents through machine learning. As data is updated in real-time at the source, so are the nodes and the computational models that act on that data. This    allows for far more complex relationships to be modeled, and facilitates the ability of the graph to understand the connections between concepts, rather than just strings in data. Ultimately this is used for optimizing decisions or operations.   Reusable Models   The flexibility of the Maana Knowledge Graph enables groups across the organization to leverage and build-upon models created by other groups, dramatically accelerating the speed at which models are created throughout the organization. These models are dynamic, and once operationalized into line-of-business applications, they learn and adapt based on the user's behaviors and provide continuous intelligence for day-to-day operations.  The Maana Computational Knowledge Graph\u2122 at the core of the platform is a network of models that are built using machine learning techniques and artificial intelligence that power AI-Driven Applications used to digitize decision support and operations.  It allows the knowledge of the business to be incrementally captured and grown, becoming more sophisticated as more projects are developed using it.  The MAANA knowledge platform offers a new way to get more out of machine learning and artificial intelligence projects and is the fastest way to digitize your business.  1.\n  1. 1.2.Maana platform architecture and GraphQL  Maana platform architecture   Insert paragraph on Maana platform architecture components \u2013 ask Donald where can you get the content from.  MAANA platform is using GraphQL, a query language for APIs and a runtime for fulfilling queries with data. GraphQL provides a complete and understandable description of the data in the API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.  With the GraphQL type system, the developers can access the full capabilities of your data from a single endpoint.  GraphQL creates a uniform API across your entire application without being limited by a specific storage engine. The developer provides functions for each field in the type system, and GraphQL calls them with optimal concurrency.  1.\n  1. 1.3.About Maana Kinds and other useful terms  Before creating a working computational knowledge graph and, it is useful to gain a basic understanding of a few notions that will help the user make most out of the MAANA portal experience.     Term  What is it?  Example      Kinds     Kinds are concepts.  Examples: People, Ships, Oil Wells, Invoices    Fields  Fields are properties within a certain concept  Examples of fields related to the People concept: age, sex, height, weight, etc.do we need this?    Instances  A particular set of values for entities within a concept.  Example of an instance: Paul, 40yrs old, male, 6', 180poundsExamples of entities related to the People concept: age, sex, height, weight, etc.    Values  A particular size, measure, number of an entity  Example of a value: 40Example of an instance: Paul, 40yrs old, male, 6', 180pounds    Relations  Connections /dependencies that can be established between fields belonging to different Kinds  Example: A Kind describing an oil well may contain a field of type String showing the name of the company operating that well. That field has a relation with the Kind containing Company Names     1.\n  1. 1.4.Knowledge Microservices  Knowledge microservices are a class of microservices that are developed for the MAANA platform.  Maana Knowledge Services form a network of GraphQL endpoints, exposing their types, queries, and mutations for direct access, as well as publishing and subscribing to network events.  The Maana platform manages these services, providing authentication, reliable messaging, (automatic) graph persistence (with search and querying), scaling, monitoring, and a rich UX.  Examples of knowledge microservices include:     Indexers  \u2022 Text\u2022 Number\u2022 Time\u2022 Geospatial\u2022 Geometric  Miners  \u2022 Statistics\u2022 Probabilities\u2022 NER/NLP  Classifiers  \u2022 Entity\u2022 Field\u2022 Document\u2022 Image            Knowledge Services can become Knowledge \"Bots\" by offering and using \"bot actions,\" which allows the service to interact more directly to users.  Users can configure, start, stop, and schedule bot actions.  Services can report on status and progress for potentially long-running, asynchronous operations, as well as report any errors or messages. Bots are microservices that \"listen\" for specific events on a system bus \u2013 Maana uses RabbitMQ for system bus \u2013 and act automatically when such events happen to mine and enrich the graph (i.e. when a raw data file is loaded into MAANA, a bot automatically analyzes it to identify mentions of entities like persons, phone numbers, values, and facts).  There are two primary scenarios to consider here: event handling and direct query/mutation.   Event Handling   When a Knowledge Service subscribes to and handles an event, such as \"fileAdded,\" it can (optionally) create an instance of a BotAction Kind by mutating the CKG.  As the service performs its operation, it can periodically update the progress (if it is deterministic) and update the status and report errors.   Queries and Mutations   A user can invoke a query or mutation either explicitly (e.g., train a classifier on labeled data) or implicitly (i.e., as part of query graph).  In such cases, the service exposes such queries and mutations as returning a BotAction.  1.\n  1. 1.5.Knowledge Applications  Knowledge Applications are applications that are built on top of the Maana CKG to help subject matter experts make better decisions faster.  A Knowledge application presents a custom interface to the end user and optimizes interaction for most common actions.  Generally a knowledge application generally provides the following functionality:   Allow user to specify question inputs  Generate recommendations  Visualize recommendations and rationale  Allow user to explore and tune inputs  Accept user decision   Knowledge applications can be developed in any language. Most languages have some level of GraphQL support.  1.\n  1. 1.6.MAANA catalogue  Maana catalogue is the repository for all components that can be used as part of MAANA knowledge solutions    How do you add/publish/update/delete components in the catalogue?    2.Defining a model in Maana    All of the following documentation uses XXX.XXX.XXX.XXX facing to represent the public URL of the system. All of the following examples use the Graphiql endpoint which is interactive, programmatic access conducted through the Graphql endpoint.  GraphQL API is organized around three main building blocks: the schema, queries, and resolvers.  Queries can be executed via GET or POST, with either the body of the query as the query string or in the body of the POST. All mutations must use the POST endpoint and have the header content type set to application/json. Also, the GraphQL server needs a resolver to know what to do with an incoming query.       _Anatomy of a GraphQL Query (_ [_source_](https://dev-blog.apollodata.com/the-anatomy-of-a-graphql-query-6dffa9e9e747)_)_  The following is an example of how to create a graph with no mutation specified, using the cURL command line tool for getting or sending files using URL syntax.  curl -v -H \"Content-Type: application/json\" -X POST -d \"{\\\"query\\\": \\\"mutation { ..... }\\\"}\" http://XXX.XXX.XXX.XXX:8003/graphql  Maana engineering team is currently implementing authentication functionality, which will be required for all clients.   How to create a graph from a GQL definition (  https://confluence.corp.maana.io/display/RD/Maana+Q+programmatic+interface )  How to add instance data  How to query instance data  How to perform complex queries (  https://confluence.corp.maana.io/display/RD/Technical+Design+Notes#TechnicalDesignNotes-Queries )   How to perform search (  https://confluence.corp.maana.io/display/RD/Maana+Q+Search+-+Technical+Design )    3.Hydrating the model with data    Steps to hydrate a model with data:   Create a service source with graphql schema . Types must correspond to Kinds on the portal endpoint XXX.XXX.XXX.XXX:8003/graphiql. Note that the service can have many Kind definitions.   mutation {  addServiceSource(input: {  name: &quot;TestService&quot;,\n\nschema: &quot;type TestKind { \\n id: ID \\n name: String! \\n something: Int! }&quot;  })  }  Creating a Service Source will return a Service ID:  {  \"data\": {  &quot;addServiceSource&quot;: &quot;54769aae-2c63-4415-9b34-74e9ceb1d789&quot;  }  }  This ID is used to establish the Service endpoint for subsequent interactions  XXX.XXX.XXX.XXX:8003/service/54769aae-2c63-4415-9b34-74e9ceb1d789/graphiql  Note: If the service is re-created by updating definitions, its service ID will change, while the old service will still be available.   Adding a single instance of the kind   mutation {  addTestKind(input: {  name: &quot;testname&quot;,\n\nsomething: 42  })  }  An ID is assigned and returned for the instance itself  {  \"data\": {  &quot;addTestKind&quot;: &quot;431f9338-95be-4f89-968c-4f2bb197965c&quot;  }  }  Once the instance data was added, we can query it using:  query {  allTestKinds {  id\n\nname\n\nsomething  }  }   Adding multiple data instances simultaneously to a kind   mutation addSomethings {  addTestKinds(input: [{  name: &quot;testname2&quot;,\n\nsomething: 45  }, {  name: &quot;testname3&quot;,\n\nsomething: 43  }  ])  }  Larger data volumes should be broken into reasonably sized chunks (i.e. up to 5,000 instances), and submitted sequentially through the endpoint.  Data can be queried using:  query {  allTestKinds {  id\n\nname\n\nsomething  }  }   4.Querying a model   1.\n  1. 4.1.Query through service end points  This is the most common way to query the data once ingested in the graph  query {  allTestKinds {  id\n\nname\n\nsomething  }  }  1.\n  1. 4.2.Query using global entry points  There are more generic ways to read Kinds from a model than through service entry points.  However when using the global entry points (rather than the service entry points), Kinds should be referenced by ID. The IDs for each kind can be obtained from the Service ID by running a query against XXX.XXX.XXX.XXX:8003  Here is an example on how to obtain a Kind IDs from the Service ID:  query foo {  serviceSource(id:\"54769aae-2c63-4415-9b34-74e9ceb1d789\") {  name\n\nkinds {\n\n  name\n\n  id\n\n}  }  }  The query above should return  {  \"data\": {  &quot;serviceSource&quot;: {\n\n  &quot;name&quot;: &quot;TestService&quot;,\n\n  &quot;kinds&quot;: [\n\n    {\n\n      &quot;name&quot;: &quot;54769aae-2c63-4415-9b34-74e9ceb1d789\\_TestKind&quot;,\n\n      &quot;id&quot;: &quot;a745e4d7-74e9-4023-8f39-bc63d6076326&quot;\n\n    }\n\n  ]\n\n}  }  }  1.\n  1. 4.3.Query using allinstances  This type of query can be used to get instances for a kind in the same format as the query entry point:  query {  allInstances(tenantId:0, kindId:\"a745e4d7-74e9-4023-8f39-bc63d6076326\") {  records {\n\n  STRING\n\n  ID\n\n}  }  }  1.\n  1. 4.4.Query across kinds  More complex queries can be used to more efficiently query across kinds. Many internal services can use this endpoint to reduce the number of DB requests required to fulfil a request.  Here is an example:  query {  kindDBQuery(kindQuery:{\n\n  kindId:&quot;fcd39416-337c-4566-b5bf-56cc8ff725d2&quot;\n\n  fieldFilters: [{\n\n    op: &quot;==&quot;\n\n    fieldName: &quot;State&quot;\n\n    value: {\n\n      STRING:&quot;WA&quot;\n\n    }\n\n  }]\n\n  and: [{\n\n    kindId:&quot;fcd39416-337c-4566-b5bf-56cc8ff725d2&quot;\n\n    toFieldName:&quot;City&quot;\n\n    fromFieldName: &quot;City&quot;\n\n    fieldFilters:[{\n\n      op: &quot;==&quot;\n\n      fieldName: &quot;Zipcode&quot;\n\n      value: {\n\n        STRING: &quot;98053&quot;\n\n      }\n\n    }]\n\n  }]\n\n}) {\n\n  records {\n\n    ID\n\n    STRING\n\n    INT\n\n    FLOAT\n\n}  }  }  The outer most kind is the type returned, while inner kinds form a DAG where each inner kind constrains its outer kinds instances. The DAG should be considered to be a graph walk, where constraints are applied at each step in the walk, data is returned only if all constraints are true.  Filters are a collection of {op, fieldname, value} triples that constrain the Kind on which they are applied.  Operators that can be used:   for Strings : \"==\" , \"!=\" , \"oneof\"   for Numbers (Int and Float) :  \"<\", \"<=\", \">\", \">=\"    5.Developing knowledge microservices   5.1.Project Setup   start with a project template in your preferred language  follow the instructions on customizing it",
            "title": "WORD CONVERSION"
        },
        {
            "location": "/developer/#maana-knowledge-service-templates",
            "text": "In an attempt to develop best-practices, code base coherence (learn once), and to ease maintenance burden, we've tried to standardize a number of things that a productive developer should not have to worry about and instead focus on adding real features.  Every project should follow a common, consistent pattern in order to reduce the tax imposed by infrastructure, such as web services and middleware, GraphQL services, logging, build, deployment, etc. As such, we recommend always   cloning  a new project from the   Maana Knowledge Service template  for your preferred language.  Once cloned, perform the customizations recommended in the template's README.md.  If your language isn't represented, we'd be happy to work with you to develop a template or just send a pull request to have it included.  1.\n  1. 5.2.Development   define GraphQL schema for the service endpoint  implement appropriate resolvers  be client (query, mutate, subscribe) to other Knowledge Services (dependencies)  stitch together existing services, providing an aggregated endpoint (to simplify client access)   1.\n  1. 5.3.Packaging  prepare deployment  managed service  : create a docker container  unmanaged service  : not our problem  1.\n  1. 5.4.Adding a knowledge microservice to the MAANA catalogue   prepare a service manifest (basically a serialized instance of Kind Service)  register the service in the catalog   Maana will:  introspect the service  create all the Kinds in KindDB  along with boilerplate for   Managed Kinds  this includes types, queries, mutations, and subscriptions  register with CKG?  boilerplate query and mutation resolvers and event emitters  schema stitching between synthetic and service-provided resolvers     Developing knowledge applications     7.Troubleshooting    8.Troubleshooting    Development Scenarios  local: configure and run a local docker machine Maana system and custom services (i.e., a \"deployment\")  this is how the Maana R&D work  emote: mixed environments - a Maana deployment is hosted elsewhere (e,g, Azure) and developing a service locally  not supported in v3.0?  if local and developing an a (locally) deployed service, then \"docker stop\" it and run/debug it manually  Project Setup  start with a project template in your preferred language  follow the instructions on customizing it  Develop  define GraphQL schema for the service endpoint  implement appropriate resolvers  be client (query, mutate, subscribe) to other Knowledge Services (dependencies)  stitch together existing services, providing an aggregated endpoint (to simplify client access)  Package  prepare deployment  managed service  : create a docker container  unmanaged service  : not our problem  Catalog  prepare a service manifest (basically a serialized instance of Kind Service)  register the service in the catalog  Maana will:  introspect the service  create all the Kinds in KindDB  along with boilerplate for   Managed Kinds  this includes types, queries, mutations, and subscriptions  register with CKG?  boilerplate query and mutation resolvers and event emitters  schema stitching between synthetic and service-provided resolvers",
            "title": "Maana Knowledge Service Templates"
        },
        {
            "location": "/administrator/",
            "text": "Administrator Guide\n\n\nDeployment Prerequisites\n\n\nGeneral Prerequisites\n\n\nPrerequisites specific to cloud deployments\n\n\nPreparation of Azure infrastructure\n\n\nPrerequisites specific to on-prem deployments\n\n\nInstalling Maana platform3\n\n\nVM configuration3\n\n\nDocker Plugins installation3\n\n\nDocker Login\n\n\nDocker Deploy\n\n\nAdding users to the MAANA platform\n\n\nConnecting to an authentication provider\n\n\nCreating tenant groups\n\n\nAssigning users to a tenant group\n\n\nCreating and managing namespaces\n\n\nSystem monitoring and maintenance\n\n\nMonitoring, logging, reporting and alerts\n\n\nResizing cluster nodes\n\n\nAdding cluster nodes\n\n\nTenant resource allocation\n\n\nApplying system updates\n\n\nBackup & restore\n\n\nDisaster recovery\n\n\nManaging Maana services catalog\n\n\nTroubleshooting\n\n\n\u200b## Technical support",
            "title": "Administrator"
        },
        {
            "location": "/administrator/#administrator-guide",
            "text": "",
            "title": "Administrator Guide"
        },
        {
            "location": "/administrator/#deployment-prerequisites",
            "text": "",
            "title": "Deployment Prerequisites"
        },
        {
            "location": "/administrator/#general-prerequisites",
            "text": "",
            "title": "General Prerequisites"
        },
        {
            "location": "/administrator/#prerequisites-specific-to-cloud-deployments",
            "text": "",
            "title": "Prerequisites specific to cloud deployments"
        },
        {
            "location": "/administrator/#preparation-of-azure-infrastructure",
            "text": "",
            "title": "Preparation of Azure infrastructure"
        },
        {
            "location": "/administrator/#prerequisites-specific-to-on-prem-deployments",
            "text": "",
            "title": "Prerequisites specific to on-prem deployments"
        },
        {
            "location": "/administrator/#installing-maana-platform3",
            "text": "",
            "title": "Installing Maana platform3"
        },
        {
            "location": "/administrator/#vm-configuration3",
            "text": "",
            "title": "VM configuration3"
        },
        {
            "location": "/administrator/#docker-plugins-installation3",
            "text": "",
            "title": "Docker Plugins installation3"
        },
        {
            "location": "/administrator/#docker-login",
            "text": "",
            "title": "Docker Login"
        },
        {
            "location": "/administrator/#docker-deploy",
            "text": "",
            "title": "Docker Deploy"
        },
        {
            "location": "/administrator/#adding-users-to-the-maana-platform",
            "text": "",
            "title": "Adding users to the MAANA platform"
        },
        {
            "location": "/administrator/#connecting-to-an-authentication-provider",
            "text": "",
            "title": "Connecting to an authentication provider"
        },
        {
            "location": "/administrator/#creating-tenant-groups",
            "text": "",
            "title": "Creating tenant groups"
        },
        {
            "location": "/administrator/#assigning-users-to-a-tenant-group",
            "text": "",
            "title": "Assigning users to a tenant group"
        },
        {
            "location": "/administrator/#creating-and-managing-namespaces",
            "text": "",
            "title": "Creating and managing namespaces"
        },
        {
            "location": "/administrator/#system-monitoring-and-maintenance",
            "text": "",
            "title": "System monitoring and maintenance"
        },
        {
            "location": "/administrator/#monitoring-logging-reporting-and-alerts",
            "text": "",
            "title": "Monitoring, logging, reporting and alerts"
        },
        {
            "location": "/administrator/#resizing-cluster-nodes",
            "text": "",
            "title": "Resizing cluster nodes"
        },
        {
            "location": "/administrator/#adding-cluster-nodes",
            "text": "",
            "title": "Adding cluster nodes"
        },
        {
            "location": "/administrator/#tenant-resource-allocation",
            "text": "",
            "title": "Tenant resource allocation"
        },
        {
            "location": "/administrator/#applying-system-updates",
            "text": "",
            "title": "Applying system updates"
        },
        {
            "location": "/administrator/#backup-restore",
            "text": "",
            "title": "Backup &amp; restore"
        },
        {
            "location": "/administrator/#disaster-recovery",
            "text": "",
            "title": "Disaster recovery"
        },
        {
            "location": "/administrator/#managing-maana-services-catalog",
            "text": "",
            "title": "Managing Maana services catalog"
        },
        {
            "location": "/administrator/#troubleshooting",
            "text": "\u200b## Technical support",
            "title": "Troubleshooting"
        }
    ]
}